<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Relaxing Ragnarok</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#111;display:flex;justify-content:center;align-items:center;height:100vh;overflow:hidden;font-family:Tahoma,Arial,sans-serif;cursor:default}
#game{position:relative;width:960px;height:640px;border:2px solid #333;overflow:hidden}
canvas{display:block}
#info{position:absolute;top:6px;left:6px;background:rgba(255,255,255,0.92);border:1px solid #888;border-radius:2px;padding:6px 10px;pointer-events:none;z-index:10;min-width:170px;font-size:11px;color:#333;box-shadow:1px 1px 3px rgba(0,0,0,0.3)}
#info .name{font-weight:bold;font-size:12px;color:#111;margin-bottom:3px}
#info .row{display:flex;align-items:center;margin:2px 0;gap:4px}
#info .lbl{width:22px;font-weight:bold;font-size:10px}
#info .bar{flex:1;height:8px;border:1px solid #666;border-radius:1px;background:#333;position:relative;min-width:100px}
#info .bar-fill{height:100%;border-radius:1px;transition:width 0.3s}
#info .hp-fill{background:linear-gradient(180deg,#6f6,#2a2)}
#info .sp-fill{background:linear-gradient(180deg,#66f,#22a)}
#info .exp-fill{background:linear-gradient(180deg,#fd4,#a80)}
#info .stat{font-size:10px;color:#555;margin-top:2px}
#lvlup{position:absolute;top:30%;left:50%;transform:translate(-50%,-50%);font-size:28px;font-weight:bold;color:#fff;text-shadow:0 0 20px #ff0,0 0 40px #fa0,-2px -2px 0 #000,2px 2px 0 #000;pointer-events:none;z-index:10;opacity:0;transition:opacity 0.5s}
#loading{position:absolute;top:0;left:0;width:100%;height:100%;background:#1a1a2e;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:100;color:#ccc;font-size:16px}
#loading .dot{display:inline-block;animation:bounce 0.6s infinite alternate}
@keyframes bounce{to{transform:translateY(-8px)}}
</style>
</head>
<body>
<div id="game">
<canvas id="c" width="960" height="640"></canvas>
<div id="info">
  <div class="name">Swordsman</div>
  <div class="stat" id="lvlText">Base Lv. 1 / Job Lv. 1</div>
  <div class="row"><span class="lbl">HP</span><div class="bar"><div class="bar-fill hp-fill" id="hpBar" style="width:100%"></div></div></div>
  <div class="row"><span class="lbl">SP</span><div class="bar"><div class="bar-fill sp-fill" id="spBar" style="width:100%"></div></div></div>
  <div class="row"><span class="lbl">EXP</span><div class="bar"><div class="bar-fill exp-fill" id="expBar" style="width:0%"></div></div></div>
  <div class="stat" id="killText">Kills: 0 | Zeny: 0</div>
</div>
<div id="lvlup"></div>
<div id="loading">Loading sprites<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></div>
</div>
<script>
const W=960,H=640;
let SCALE=1.8;
let S={}; // settings - loaded from settings.json, with defaults
const DEFAULTS={spawning:{max_monsters:28,spawn_timer_min:0.15,spawn_timer_random:0.35,initial_monster_count:20},player:{initial_str:10,initial_agi:8,move_speed:2.8,initial_atk_cooldown:1000,base_exp_max:100,job_exp_max:80,attack_range:65},combat:{damage_base:25,damage_per_level:3,damage_variance:15,crit_chance:0.15,crit_multiplier:2.5,cleave_chance:0.4,cleave_damage_ratio:0.5,cleave_range:60,double_attack_chance:0.3,double_attack_delay_ms:350},progression:{exp_multiplier_per_level:1.25,job_exp_multiplier_per_level:1.2,job_exp_ratio:0.7,str_per_level:2,atk_cooldown_reduction_per_level:4,min_atk_cooldown:500,zeny_ratio:0.25,zeny_bonus_max:10},boss:{kill_interval:30,scale_multiplier:1.4,speed_min:0.15,speed_random:0.15,aura_size:45,aura_pulse_speed:4,hp_bar_width:80,hp_bar_height:6,escort_count_min:5,escort_count_random:3,escort_distance_min:70,escort_distance_random:20,candidate_max_level:80,candidate_max_hp:20000,level_match_tolerance:20,selection_level_diff:25,death_shake_duration:0.3,zeny_multiplier:0.5,champion_hp_multiplier:3,champion_exp_multiplier:3},monsters:{speed_min:0.3,speed_random:0.4,wander_timer_min:1.5,wander_timer_random:3,bounds_padding_x:30,bounds_padding_top:60,bounds_padding_bottom:30,frame_duration:0.12,death_duration:0.5,hurt_duration:0.15},visuals:{sprite_scale:1.8,shake_magnitude:30,crit_shake_duration:0.15,dmg_num_rise_speed:70,dmg_num_lifetime:1.5,dmg_num_crit_font_size:48,dmg_num_normal_font_size:38,dmg_num_stroke_width:5,dmg_num_x_offset_range:20,dmg_num_crit_scale:1.3,levelup_display_duration:2},particles:{lifetime_min:0.4,lifetime_random:0.4,speed_min:1,speed_random:3,size_min:2,size_random:4,gravity:5,crit_count:5,boss_death_gold:20,boss_death_type:15,boss_death_white:10,normal_death_type:12,normal_death_white:4,levelup_gold:20,levelup_white:10},items:{drop_chance:0.4,drop_types:['jellyfish','apple','knife','candy'],spawn_offset_x:30,spawn_offset_y:20,despawn_time:2.5,bob_speed:4,bob_amplitude:2},loading:{parallel_sprite_loaders:5,sprite_load_delay_ms:20,auto_extract_target_height:80,frame_extract_min_gap:3,frame_extract_min_size:8,frame_extract_max_frames:8,frame_extract_alpha_threshold:50}};
function mergeDefaults(target,defaults){
  const result={};
  for(const k of Object.keys(defaults)){
    if(typeof defaults[k]==='object'&&!Array.isArray(defaults[k])&&defaults[k]!==null){
      result[k]=mergeDefaults(target&&target[k]||{},defaults[k]);
    }else{result[k]=target&&target[k]!==undefined?target[k]:defaults[k]}
  }
  return result;
}
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d');
const lvlupEl=document.getElementById('lvlup');

// Audio
const audioCtx=new(window.AudioContext||window.webkitAudioContext)();
function playSound(freq,dur,vol=0.3,type='square'){
  const o=audioCtx.createOscillator(),g=audioCtx.createGain();
  o.type=type;o.frequency.value=freq;
  g.gain.setValueAtTime(vol,audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur);
  o.connect(g);g.connect(audioCtx.destination);
  o.start();o.stop(audioCtx.currentTime+dur);
}
function sndHit(){playSound(200,0.08,0.2);playSound(400,0.05,0.15,'sawtooth')}
function sndCrit(){playSound(600,0.1,0.3);playSound(300,0.12,0.25,'sawtooth');playSound(800,0.06,0.2)}
function sndDie(){playSound(150,0.15,0.2,'sawtooth');playSound(100,0.2,0.15)}
function sndLvl(){[523,659,784,1047].forEach((f,i)=>setTimeout(()=>playSound(f,0.2,0.2,'sine'),i*100))}

// Sprite frame definitions
const PORING_IDLE=[
  [7,11,37,36],[63,10,39,37],[122,9,41,39],[189,14,39,33],
  [251,12,37,36],[310,12,39,37],[371,10,41,39],[438,16,39,33]
];
const PORING_HURT=[[12,213,37,36],[59,216,39,32]];

const POPORING_IDLE=[
  [13,14,37,36],[69,13,39,37],[127,12,41,39],[187,17,39,33],
  [242,15,37,36],[299,14,39,37],[359,12,41,39],[423,17,39,33]
];
const POPORING_HURT=[[17,220,37,36],[75,224,39,32]];

// Drops (orange poring)
const DROPS_IDLE=[
  [15,19,37,36],[69,18,39,37],[127,16,41,39],[185,22,39,33],
  [243,18,37,36],[299,18,39,37],[363,15,41,39],[425,21,39,33]
];
const DROPS_HURT=[[10,217,37,36],[66,221,39,32]];

// Fabre (caterpillar)
const FABRE_IDLE=[
  [10,11,34,27],[58,11,34,27],[108,11,31,27],[154,12,33,26],
  [205,12,33,26],[251,12,32,25],[299,12,30,25],[344,13,32,26]
];
const FABRE_HURT=[[10,57,33,26],[60,55,41,26]];

// Lunatic (rabbit)
const LUNATIC_IDLE=[
  [11,18,29,26],[55,18,30,25],[98,20,33,22],[142,18,30,25],
  [186,19,31,27],[233,20,33,26],[282,20,36,26],[333,20,33,26]
];
const LUNATIC_HURT=[[14,350,29,27],[57,350,29,27]];

// Spore (mushroom)
const SPORE_IDLE=[
  [21,18,48,54],[111,19,48,52],[201,19,48,51],[291,19,48,52],
  [381,18,48,54],[471,18,48,53],[561,18,48,53],[651,18,48,53]
];
const SPORE_HURT=[[18,403,48,54],[108,405,48,50]];

// Wolf
const WOLF_IDLE=[
  [8,13,65,59],[93,12,76,62],[195,11,75,64],[293,16,75,60],
  [400,16,68,60],[500,11,67,64],[592,9,66,70],[685,9,66,70]
];
const WOLF_HURT=[];

// Skeleton
const SKELETON_IDLE=[
  [16,20,67,79],[119,19,62,81],[218,19,63,81],[318,19,63,81],
  [421,20,58,80],[522,19,55,82],[619,19,61,82],[720,20,60,80]
];
const SKELETON_HURT=[];

// Directions: 0=S, 1=SW, 2=W, 3=NW, 4=N  (5=NE, 6=E, 7=SE mirror 3,2,1)
// Standing frames per direction (Row 0)
const SWORD_STAND_DIR=[
  [10,10,36,72],[58,12,25,70],[95,13,33,69],[140,14,41,68],[193,12,33,70]
];
// Walking frames per direction, 8 frames each
const SWORD_WALK_DIR=[
  // S (Row 1)
  [[10,113,37,70],[59,112,35,71],[106,110,32,73],[150,111,34,72],[196,113,37,70],[245,112,35,71],[292,110,32,73],[336,110,34,73]],
  // SW (Row 2)
  [[10,212,32,70],[54,215,38,67],[104,217,44,65],[160,215,37,67],[209,215,32,67],[253,214,36,68],[301,214,36,68],[349,212,35,70]],
  // W (Row 3)
  [[10,312,25,70],[47,313,32,69],[91,315,44,67],[147,314,36,68],[195,314,25,68],[232,316,32,66],[276,315,43,67],[331,314,37,68]],
  // NW (Row 4)
  [[10,415,27,68],[49,414,29,69],[90,415,33,68],[135,416,28,67],[175,420,30,63],[217,420,38,63],[267,420,44,63],[323,419,39,64]],
  // N (Row 5)
  [[10,515,36,67],[58,511,35,71],[105,513,33,69],[150,513,34,69],[196,515,36,67],[244,511,35,71],[291,513,33,69],[336,513,34,69]]
];
// Attack body frames per direction (5 frames each)
const SWORD_ATK_DIR=[
  // S (Row 6)
  [[10,612,45,70],[67,611,41,71],[120,615,43,67],[175,622,47,60],[234,624,47,58]],
  // SW (Row 7)
  [[10,715,33,67],[55,715,33,67],[100,713,39,69],[151,721,43,61],[206,722,43,60]],
  // W (Row 8)
  [[10,818,50,64],[72,816,40,66],[124,814,40,68],[228,819,54,63],[294,821,54,61]],
  // NW (Row 9)
  [[10,920,41,62],[63,917,41,65],[116,916,38,66],[214,921,45,61],[271,923,45,59]],
  // N (reuse NW)
  [[10,920,41,62],[63,917,41,65],[116,916,38,66],[214,921,45,61],[271,923,45,59]]
];

// Head frames per direction (Row 0, used for all states to keep hair consistent)
const HEAD_DIR=[
  [10,15,28,25],[61,16,26,24],[112,16,24,24],[161,16,26,24],[210,15,28,25]
];

// Weapon attack frames per direction (5 frames each, matched 1:1 with body frames)
const WPN_ATK_DIR=[
  // S: weapon frames 0,2,3,4,5 from 7-frame sequence
  [[4,290,32,80],[77,294,25,64],[110,299,51,79],[166,299,38,74],[216,297,86,68]],
  // SW: weapon frames 0,2,3,4,5
  [[5,403,24,79],[68,404,26,67],[101,413,31,65],[141,412,78,70],[228,407,28,64]],
  // W: weapon frames 0,1,2,3,4
  [[4,513,34,95],[48,514,24,93],[80,519,30,88],[119,525,53,86],[182,525,110,69]],
  // NW: actual NW section frames 0,1,2,3,4
  [[6,639,30,78],[46,637,23,82],[77,643,24,62],[111,650,41,63],[156,649,89,74]],
  // N: reuse NW weapon frames
  [[6,639,30,78],[46,637,23,82],[77,643,24,62],[111,650,41,63],[156,649,89,74]]
];

// Per-frame weapon hand position on the body as [xFrac, yFrac] of body frame
// (0,0)=top-left, (1,1)=bottom-right -- where the character grips the weapon
const WPN_HAND_POS=[
  // S: hand on right side, moves from upper-right to lower-right during swing
  [[0.67,0.11],[0.66,0.20],[0.70,0.33],[0.72,0.37],[0.72,0.43]],
  // SW: hand on right, similar arc
  [[0.67,0.12],[0.67,0.22],[0.72,0.32],[0.70,0.36],[0.70,0.42]],
  // W: hand starts left (behind), swings right (forward)
  [[0.30,0.13],[0.38,0.18],[0.45,0.29],[0.56,0.32],[0.65,0.36]],
  // NW: similar to W
  [[0.37,0.08],[0.39,0.12],[0.45,0.23],[0.56,0.30],[0.62,0.34]],
  // N: hand on left side (facing away, weapon arm on viewer's left)
  [[0.33,0.11],[0.34,0.20],[0.30,0.33],[0.28,0.37],[0.28,0.43]]
];

// Weapon grip position: how far below center the grip is (fraction of weapon height)
// Early frames: grip near bottom (sword vertical), late frames: grip near center (horizontal)
const WPN_GRIP_OFF=[0.35, 0.30, 0.20, 0.10, 0.0];

// Head anchor offsets per body state [yOffset from body top, in native sprite pixels]
// Attack uses per-frame values since body crouches during swing
const HEAD_ANCHOR={stand:11, walk:19, attack:11};
const HEAD_ANCHOR_ATK=[11, 11, 10, 9, 8];

// Direction helpers
function moveDir(dx,dy){
  const a=((Math.atan2(dy,dx)+Math.PI*2)%(Math.PI*2));
  const s=Math.round(a/(Math.PI/4))%8;
  return [6,7,0,1,2,3,4,5][s]; // E,SE,S,SW,W,NW,N,NE -> dir enum
}
function dirInfo(dir){
  if(dir<=4)return[dir,false];
  return[[3,true],[2,true],[1,true]][dir-5]; // NE->NW flip, E->W flip, SE->SW flip
}

// Load sprites
const TOTAL_SPRITES=11;
const sprites={};
let loaded=0;
let statsLoaded=false;
let monsterStatsDB={};
let manifestData=[];
let manifestLoaded=false;
let settingsLoaded=false;
function tryStart(){if(loaded===TOTAL_SPRITES&&statsLoaded&&manifestLoaded&&settingsLoaded)startGame()}
function loadImg(name,src){
  const img=new Image();
  img.onload=()=>{sprites[name]=img;loaded++;tryStart()};
  img.onerror=()=>{console.error('Failed to load '+src);loaded++;tryStart()};
  img.src=src;
}
loadImg('poring','sprites/enemies/Poring,_Santa_Poring,_&amp_Angeling_126666.png');
loadImg('poporing','sprites/enemies/Poporing_126668.png');
loadImg('sword','sprites/classes/Swordsman_141350.png');
loadImg('head','sprites/heads/head_male_brown.png');
loadImg('weapon','sprites/weapons/swordman_swords.png');
loadImg('drops','sprites/enemies/Drops_127279.png');
loadImg('fabre','sprites/enemies/Fabre_127228.png');
loadImg('lunatic','sprites/enemies/Lunatic_126936.png');
loadImg('spore','sprites/enemies/Spore_126582.png');
loadImg('wolf','sprites/enemies/Wolf_126445.png');
loadImg('skeleton','sprites/enemies/Skeleton_126591.png');
fetch('monster_stats.json').then(r=>r.json()).then(data=>{monsterStatsDB=data;statsLoaded=true;tryStart()}).catch(()=>{statsLoaded=true;tryStart()});
fetch('sprites/manifest.json').then(r=>r.json()).then(data=>{manifestData=data;manifestLoaded=true;tryStart()}).catch(()=>{manifestLoaded=true;tryStart()});
fetch('settings.json').then(r=>r.json()).then(data=>{S=mergeDefaults(data,DEFAULTS);SCALE=S.visuals.sprite_scale;settingsLoaded=true;tryStart()}).catch(()=>{S=DEFAULTS;SCALE=S.visuals.sprite_scale;settingsLoaded=true;tryStart()});

// Terrain
let terrainCanvas;
function genTerrain(){
  terrainCanvas=document.createElement('canvas');
  terrainCanvas.width=W;terrainCanvas.height=H;
  const tc=terrainCanvas.getContext('2d');
  // Base grass
  tc.fillStyle='#5d8e3c';
  tc.fillRect(0,0,W,H);
  // Large color patches for natural variation
  for(let i=0;i<300;i++){
    const x=Math.random()*W,y=Math.random()*H;
    const r=20+Math.random()*80;
    const g=120+Math.random()*50;
    tc.fillStyle=`rgba(${50+Math.random()*50},${g},${30+Math.random()*40},0.08)`;
    tc.beginPath();
    tc.ellipse(x,y,r,r*0.7,Math.random()*Math.PI*2,0,Math.PI*2);
    tc.fill();
  }
  // Lighter grass patches
  for(let i=0;i<150;i++){
    const x=Math.random()*W,y=Math.random()*H;
    const r=10+Math.random()*50;
    tc.fillStyle=`rgba(${80+Math.random()*40},${150+Math.random()*40},${50+Math.random()*30},0.06)`;
    tc.beginPath();
    tc.ellipse(x,y,r,r*0.6,Math.random()*Math.PI*2,0,Math.PI*2);
    tc.fill();
  }
  // Dirt patches
  const dirtPatches=[
    {x:150,y:200,rx:90,ry:60},{x:700,y:150,rx:110,ry:70},
    {x:400,y:500,rx:80,ry:55},{x:800,y:450,rx:95,ry:65},
    {x:250,y:420,rx:70,ry:50},{x:600,y:300,rx:60,ry:40},
    {x:100,y:550,rx:75,ry:45},{x:850,y:250,rx:65,ry:50}
  ];
  for(const d of dirtPatches){
    const grad=tc.createRadialGradient(d.x,d.y,0,d.x,d.y,d.rx);
    grad.addColorStop(0,'rgba(155,130,80,0.55)');
    grad.addColorStop(0.5,'rgba(145,120,70,0.35)');
    grad.addColorStop(0.8,'rgba(130,110,65,0.15)');
    grad.addColorStop(1,'rgba(120,100,60,0)');
    tc.fillStyle=grad;
    tc.beginPath();
    tc.ellipse(d.x,d.y,d.rx,d.ry,Math.random()*0.5-0.25,0,Math.PI*2);
    tc.fill();
  }
  // Small grass detail marks
  for(let i=0;i<500;i++){
    const x=Math.random()*W,y=Math.random()*H;
    tc.fillStyle=`rgba(${40+Math.random()*30},${100+Math.random()*60},${30+Math.random()*20},0.15)`;
    tc.fillRect(x,y,1+Math.random()*2,1+Math.random()*3);
  }
  // Subtle vignette
  const vg=tc.createRadialGradient(W/2,H/2,200,W/2,H/2,500);
  vg.addColorStop(0,'rgba(0,0,0,0)');
  vg.addColorStop(1,'rgba(0,0,0,0.15)');
  tc.fillStyle=vg;
  tc.fillRect(0,0,W,H);
}

// Game state
let player,monsters=[],dmgNums=[],particles=[],items=[];
let kills=0,zeny=0;
let shakeX=0,shakeY=0,shakeTimer=0;
let lastTime=0,gameTime=0,spawnTimer=0;
let clickTarget=null;
let lvlupTimer=0;
let monsterSortOrder=[];
let bossCandidates=[];
let killsSinceLastBoss=0;
const ELEMENT_COLORS={Fire:'#ff6633',Water:'#3399ff',Earth:'#cc9933',Wind:'#66cc66',Poison:'#99cc33',Holy:'#ffff99',Dark:'#9933cc',Ghost:'#ccccff',Undead:'#669999',Neutral:'#ffffff'};
const HAND_TUNED=new Set(['poring','poporing','drops','fabre','lunatic','spore','wolf','skeleton']);

function initPlayer(){
  player={
    x:W/2,y:H/2,
    state:'idle',direction:0,
    frame:0,frameTimer:0,
    atkTimer:0,atkCooldown:S.player.initial_atk_cooldown,
    target:null,
    baseLv:1,jobLv:1,
    exp:0,expMax:S.player.base_exp_max,jobExp:0,jobExpMax:S.player.job_exp_max,
    str:S.player.initial_str,agi:S.player.initial_agi,
    moveSpeed:S.player.move_speed
  };
}

const MONSTER_TYPES={
  poring:{
    name:'Poring',hp:50,exp:12,zeny:10,minLevel:1,weight:10,
    sprite:'poring',scale:SCALE,idle:PORING_IDLE,hurt:PORING_HURT,
    deathColor:'#ffaaaa',shadow:[16,7]
  },
  poporing:{
    name:'Poporing',hp:80,exp:18,zeny:15,minLevel:1,weight:8,
    sprite:'poporing',scale:SCALE,idle:POPORING_IDLE,hurt:POPORING_HURT,
    deathColor:'#aaffaa',shadow:[16,7]
  },
  fabre:{
    name:'Fabre',hp:63,exp:11,zeny:8,minLevel:3,weight:7,
    sprite:'fabre',scale:SCALE,idle:FABRE_IDLE,hurt:FABRE_HURT,
    deathColor:'#aaffaa',shadow:[14,6]
  },
  drops:{
    name:'Drops',hp:70,exp:15,zeny:12,minLevel:3,weight:7,
    sprite:'drops',scale:SCALE,idle:DROPS_IDLE,hurt:DROPS_HURT,
    deathColor:'#ffcc88',shadow:[16,7]
  },
  lunatic:{
    name:'Lunatic',hp:95,exp:22,zeny:18,minLevel:5,weight:6,
    sprite:'lunatic',scale:SCALE,idle:LUNATIC_IDLE,hurt:LUNATIC_HURT,
    deathColor:'#ffffff',shadow:[14,6]
  },
  spore:{
    name:'Spore',hp:130,exp:32,zeny:25,minLevel:8,weight:5,
    sprite:'spore',scale:SCALE*0.85,idle:SPORE_IDLE,hurt:SPORE_HURT,
    deathColor:'#cc88ff',shadow:[18,8]
  },
  wolf:{
    name:'Wolf',hp:200,exp:48,zeny:35,minLevel:11,weight:4,
    sprite:'wolf',scale:SCALE*0.7,idle:WOLF_IDLE,hurt:WOLF_HURT,
    deathColor:'#888888',shadow:[22,9]
  },
  skeleton:{
    name:'Skeleton',hp:280,exp:68,zeny:50,minLevel:14,weight:3,
    sprite:'skeleton',scale:SCALE*0.75,idle:SKELETON_IDLE,hurt:SKELETON_HURT,
    deathColor:'#cccccc',shadow:[20,8]
  }
};

function spawnMonster(x,y){
  // Build list of available types based on player level (exclude boss types)
  const available=[];
  for(const [key,t] of Object.entries(MONSTER_TYPES)){
    if(player.baseLv>=t.minLevel&&!t.isBossType)available.push([key,t]);
  }
  // Dynamic weighted selection: reduce weight for monsters far below player level
  const dynWeights=available.map(([key,t])=>{
    const lvDiff=Math.max(0,player.baseLv-(t.realLevel||1));
    return t.weight/(1+lvDiff/10);
  });
  const totalW=dynWeights.reduce((s,w)=>s+w,0);
  let r=Math.random()*totalW;
  let chosenIdx=0;
  for(let i=0;i<dynWeights.length;i++){
    r-=dynWeights[i];
    if(r<=0){chosenIdx=i;break}
  }
  const [typeKey,typeDef]=available[chosenIdx];
  const m={
    x:x!==undefined?x:50+Math.random()*(W-100),
    y:y!==undefined?y:80+Math.random()*(H-130),
    type:typeKey,
    hp:typeDef.hp,maxHp:typeDef.hp,
    state:'idle',
    frame:0,frameTimer:0,
    hurtTimer:0,dieTimer:0,
    wanderAngle:Math.random()*Math.PI*2,
    wanderTimer:Math.random()*S.monsters.wander_timer_random,
    speed:S.monsters.speed_min+Math.random()*S.monsters.speed_random,
    expReward:typeDef.exp,
    zenyReward:typeDef.zeny
  };
  monsters.push(m);
}

// Damage numbers
function addDmgNum(x,y,val,isCrit,isMiss){
  dmgNums.push({x,y:y-20,val,isCrit,isMiss,age:0,startY:y-20,
    offsetX:(Math.random()-0.5)*S.visuals.dmg_num_x_offset_range,scale:isCrit?S.visuals.dmg_num_crit_scale:1});
}

function addParticles(x,y,color,count){
  for(let i=0;i<count;i++){
    const angle=Math.random()*Math.PI*2;
    const speed=S.particles.speed_min+Math.random()*S.particles.speed_random;
    particles.push({
      x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed-2,
      color,size:S.particles.size_min+Math.random()*S.particles.size_random,age:0,maxAge:S.particles.lifetime_min+Math.random()*S.particles.lifetime_random,
      gravity:S.particles.gravity
    });
  }
}

function addItem(x,y,type){
  items.push({x:x+(Math.random()-0.5)*S.items.spawn_offset_x,y:y+(Math.random()-0.5)*S.items.spawn_offset_y,type,age:0});
}

function processMonsterStats(){
  const jsonMap={drops:'Drops',lunatic:'Lunatic',fabre:'Fabre',spore:'Spore',skeleton:'Skeleton',poporing:'Poporing',wolf:'Wolf'};
  for(const [key,jsonKey] of Object.entries(jsonMap)){
    const s=monsterStatsDB[jsonKey];
    if(!s)continue;
    const mt=MONSTER_TYPES[key];
    mt.realLevel=s.level;mt.hp=s.hp;mt.exp=s.base_exp;mt.jobExp=s.job_exp||0;
    mt.zeny=Math.floor(s.base_exp*S.progression.zeny_ratio);mt.defense=s.defense||0;
    mt.allStats=(s.str||0)+(s.agi||0)+(s.vit||0)+(s.int||0)+(s.dex||0)+(s.luk||0);
    mt.attackMin=s.attack_min||0;mt.attackMax=s.attack_max||0;
  }
  // Poring not in rAthena DB - use estimated values
  MONSTER_TYPES.poring.realLevel=1;MONSTER_TYPES.poring.hp=50;MONSTER_TYPES.poring.exp=150;
  MONSTER_TYPES.poring.zeny=10;MONSTER_TYPES.poring.defense=0;MONSTER_TYPES.poring.allStats=6;
  MONSTER_TYPES.poring.attackMin=1;MONSTER_TYPES.poring.attackMax=2;
  // Composite score using ALL stats: level, hp, attack, defense, base stats
  const entries=Object.entries(MONSTER_TYPES);
  for(const [key,mt] of entries){
    mt.score=(mt.realLevel||1)*2+(mt.hp||50)/50+((mt.attackMin||0)+(mt.attackMax||0))/5+(mt.defense||0)/10+(mt.allStats||0)/20;
  }
  entries.sort((a,b)=>a[1].score-b[1].score);
  monsterSortOrder=entries.map(e=>e[0]);
  entries.forEach(([key,type],i)=>{
    type.weight=Math.max(2,10-i);
    type.minLevel=i===0?1:Math.max(1,Math.ceil(type.realLevel*0.5));
    type.sortOrder=i;
  });
  // Collect boss candidates from JSON (reasonable level/HP)
  for(const [key,s] of Object.entries(monsterStatsDB)){
    if(!s.is_boss||s.hp<=0||s.level<=0)continue;
    if(s.level<=S.boss.candidate_max_level&&s.hp<S.boss.candidate_max_hp){
      bossCandidates.push({name:s.name,hp:s.hp,exp:s.base_exp||0,level:s.level,isMvp:s.is_mvp||false});
    }
  }
  bossCandidates.sort((a,b)=>a.level-b.level);
}

function findBossForLevel(plvl){
  let best=null,bestDiff=Infinity;
  for(const b of bossCandidates){
    const diff=Math.abs(b.level-plvl);
    if(diff<bestDiff){bestDiff=diff;best=b}
  }
  return bestDiff<=S.boss.level_match_tolerance?best:null;
}

function spawnBossGroup(){
  // Try to find a loaded boss sprite near player level
  let bossKey=null,bestDiff=Infinity;
  for(const [key,type] of Object.entries(MONSTER_TYPES)){
    if(!type.isBossType)continue;
    const diff=Math.abs((type.realLevel||1)-player.baseLv);
    if(diff<bestDiff&&diff<=S.boss.selection_level_diff){bestDiff=diff;bossKey=key}
  }
  // Fallback: champion of current highest tier
  let currentTierKey='poring';
  for(const [key,type] of Object.entries(MONSTER_TYPES)){
    if(!type.isBossType&&player.baseLv>=type.minLevel)currentTierKey=key;
  }
  if(!bossKey)bossKey=currentTierKey;
  const typeDef=MONSTER_TYPES[bossKey];
  const isTrueBoss=!!typeDef.isBossType;
  const boss=!isTrueBoss?findBossForLevel(player.baseLv):null;
  const bossName=isTrueBoss?typeDef.name:(boss?boss.name:'Champion '+typeDef.name);
  const bossHp=isTrueBoss?typeDef.hp:(boss?Math.max(boss.hp,typeDef.hp*S.boss.champion_hp_multiplier):typeDef.hp*S.boss.champion_hp_multiplier);
  const bossExp=isTrueBoss?typeDef.exp:(boss?boss.exp:typeDef.exp*S.boss.champion_exp_multiplier);
  // Spawn boss
  const bx=150+Math.random()*(W-300);
  const by=120+Math.random()*(H-240);
  monsters.push({
    x:bx,y:by,type:bossKey,
    hp:bossHp,maxHp:bossHp,
    state:'idle',frame:0,frameTimer:0,
    hurtTimer:0,dieTimer:0,
    wanderAngle:Math.random()*Math.PI*2,wanderTimer:Math.random()*S.monsters.wander_timer_random,
    speed:S.boss.speed_min+Math.random()*S.boss.speed_random,
    expReward:bossExp,zenyReward:Math.floor(bossExp*S.boss.zeny_multiplier),
    isBoss:true,bossName:bossName
  });
  // Spawn ring of escort monsters
  const escortCount=S.boss.escort_count_min+Math.floor(Math.random()*S.boss.escort_count_random);
  for(let i=0;i<escortCount;i++){
    const angle=(Math.PI*2/escortCount)*i;
    const dist=S.boss.escort_distance_min+Math.random()*S.boss.escort_distance_random;
    spawnMonster(
      Math.max(30,Math.min(W-30,bx+Math.cos(angle)*dist)),
      Math.max(60,Math.min(H-30,by+Math.sin(angle)*dist))
    );
  }
}

// Auto-extract idle frames from sprite sheet (Row 0)
function extractFrames(img){
  const w=img.width,h=img.height;
  const tc=document.createElement('canvas');tc.width=w;tc.height=h;
  const tx=tc.getContext('2d');tx.drawImage(img,0,0);
  const d=tx.getImageData(0,0,w,h).data;
  // Find first row band (continuous rows with non-transparent pixels)
  let r0=-1,r1=-1;
  for(let y=0;y<h;y++){
    let has=false;
    for(let x=0;x<w;x+=2){if(d[(y*w+x)*4+3]>S.loading.frame_extract_alpha_threshold){has=true;break}}
    if(has&&r0===-1)r0=y;
    if(!has&&r0!==-1&&r1===-1){r1=y;break}
  }
  if(r0===-1)return null;
  if(r1===-1)r1=Math.min(r0+Math.floor(h/3),h);
  // Find columns with content in row band
  const colHas=new Uint8Array(w);
  for(let x=0;x<w;x++){
    for(let y=r0;y<r1;y+=2){if(d[(y*w+x)*4+3]>S.loading.frame_extract_alpha_threshold){colHas[x]=1;break}}
  }
  // Extract frame boundaries (min 3px gap between frames)
  const frames=[];
  let inF=false,fStart=0,gap=0;
  for(let x=0;x<=w;x++){
    const has=x<w?colHas[x]:0;
    if(has){if(!inF){fStart=x;inF=true}gap=0}
    else if(inF){
      gap++;
      if(gap>=S.loading.frame_extract_min_gap||x>=w){
        const fEnd=x-gap;
        // Get tight Y bounds for this frame
        let yMin=r1,yMax=r0;
        for(let fy=r0;fy<r1;fy++){
          for(let fx=fStart;fx<=fEnd;fx++){
            if(d[(fy*w+fx)*4+3]>S.loading.frame_extract_alpha_threshold){if(fy<yMin)yMin=fy;if(fy>yMax)yMax=fy;break}
          }
        }
        if(fEnd-fStart>=S.loading.frame_extract_min_size&&yMax-yMin>=S.loading.frame_extract_min_size){
          frames.push([fStart,yMin,fEnd-fStart,yMax-yMin+1]);
        }
        inF=false;gap=0;
        if(frames.length>=S.loading.frame_extract_max_frames)break;
      }
    }
  }
  return frames.length>=2?frames:null;
}

// Compute composite stat score for sorting
function monsterScore(s){
  return (s.level||1)*2+(s.hp||0)/50+((s.attack_min||0)+(s.attack_max||0))/5
    +(s.defense||0)/10+((s.str||0)+(s.agi||0)+(s.vit||0)+(s.int||0)+(s.dex||0)+(s.luk||0))/20;
}

// Build full monster registry from manifest + stats, progressively load sprites
function buildAllMonsters(){
  const enemies=manifestData.filter(e=>e.subfolder==='enemies');
  const queue=[];
  for(const entry of enemies){
    // Extract monster key from filename: "Wolf_126445.png" -> "Wolf"
    const base=entry.file.split('/').pop().replace('.png','');
    const match=base.match(/^(.+)_(\d{5,6})$/);
    if(!match)continue;
    let key=match[1];
    // Try to find stats - direct key match first
    let stats=monsterStatsDB[key];
    // For compound names like "Poring,_Santa_Poring,_&amp_Angeling", try first part
    if(!stats&&(key.includes(',')||key.includes('&amp'))){
      const parts=key.split(/,_|_&amp_/).map(s=>s.trim());
      for(const p of parts){if(monsterStatsDB[p]){stats=monsterStatsDB[p];key=p;break}}
    }
    if(!stats||stats.hp<=0)continue;
    // Skip hand-tuned monsters (already loaded with precise frame data)
    const iKey=key.toLowerCase().replace(/[^a-z0-9]/g,'_');
    if(HAND_TUNED.has(iKey))continue;
    queue.push({key,iKey,name:stats.name,file:entry.file,stats,
      score:monsterScore(stats),isBoss:stats.is_boss||false});
  }
  // Sort by composite score (weakest first = loaded first)
  queue.sort((a,b)=>a.score-b.score);
  // Progressive loading with 5 parallel streams
  let idx=0;
  function loadNext(){
    if(idx>=queue.length)return;
    const mon=queue[idx++];
    const img=new Image();
    img.onload=()=>{
      const frames=extractFrames(img);
      if(frames){
        const sprKey='e_'+mon.iKey;
        sprites[sprKey]=img;
        const avgH=frames.reduce((s,f)=>s+f[3],0)/frames.length;
        const avgW=frames.reduce((s,f)=>s+f[2],0)/frames.length;
        const sc=Math.min(SCALE,S.loading.auto_extract_target_height/avgH);
        MONSTER_TYPES[sprKey]={
          name:mon.name,hp:mon.stats.hp,exp:mon.stats.base_exp||0,
          zeny:Math.floor((mon.stats.base_exp||0)*S.progression.zeny_ratio),
          minLevel:Math.max(1,Math.ceil((mon.stats.level||1)*0.5)),
          weight:mon.isBoss?0:5,
          sprite:sprKey,scale:sc,
          idle:frames,hurt:[frames[0]],
          deathColor:ELEMENT_COLORS[mon.stats.element]||'#ffffff',
          shadow:[Math.max(12,Math.floor(avgW*sc*0.25)),Math.max(5,Math.floor(avgH*sc*0.12))],
          realLevel:mon.stats.level||1,
          defense:mon.stats.defense||0,
          attackMin:mon.stats.attack_min||0,
          attackMax:mon.stats.attack_max||0,
          allStats:(mon.stats.str||0)+(mon.stats.agi||0)+(mon.stats.vit||0)+(mon.stats.int||0)+(mon.stats.dex||0)+(mon.stats.luk||0),
          score:mon.score,
          isBossType:mon.isBoss
        };
      }
      setTimeout(loadNext,S.loading.sprite_load_delay_ms);
    };
    img.onerror=()=>{setTimeout(loadNext,5)};
    img.src=mon.file;
  }
  for(let i=0;i<S.loading.parallel_sprite_loaders;i++)loadNext();
}

// Update
function update(dt){
  gameTime+=dt;
  // Spawn
  spawnTimer-=dt;
  if(spawnTimer<=0&&monsters.filter(m=>m.state!=='dead').length<S.spawning.max_monsters){
    spawnMonster();
    spawnTimer=S.spawning.spawn_timer_min+Math.random()*S.spawning.spawn_timer_random;
  }
  // Shake
  if(shakeTimer>0){
    shakeTimer-=dt;
    shakeX=(Math.random()-0.5)*shakeTimer*S.visuals.shake_magnitude;
    shakeY=(Math.random()-0.5)*shakeTimer*S.visuals.shake_magnitude;
  }else{shakeX=0;shakeY=0}
  // Lvlup
  if(lvlupTimer>0){
    lvlupTimer-=dt;
    if(lvlupTimer<=0)lvlupEl.style.opacity='0';
  }
  // Update monsters
  for(const m of monsters){
    if(m.state==='dead')continue;
    if(m.state==='dying'){
      m.dieTimer+=dt;
      if(m.dieTimer>S.monsters.death_duration){m.state='dead';continue}
      continue;
    }
    if(m.hurtTimer>0)m.hurtTimer-=dt;
    // Animate
    m.frameTimer+=dt;
    if(m.frameTimer>S.monsters.frame_duration){
      m.frameTimer=0;
      const fc=MONSTER_TYPES[m.type]?MONSTER_TYPES[m.type].idle.length:8;
      m.frame=(m.frame+1)%fc;
    }
    // Wander
    if(m.state==='idle'){
      m.wanderTimer-=dt;
      if(m.wanderTimer<=0){
        m.wanderAngle=Math.random()*Math.PI*2;
        m.wanderTimer=S.monsters.wander_timer_min+Math.random()*S.monsters.wander_timer_random;
      }
      m.x+=Math.cos(m.wanderAngle)*m.speed;
      m.y+=Math.sin(m.wanderAngle)*m.speed;
      m.x=Math.max(S.monsters.bounds_padding_x,Math.min(W-S.monsters.bounds_padding_x,m.x));
      m.y=Math.max(S.monsters.bounds_padding_top,Math.min(H-S.monsters.bounds_padding_bottom,m.y));
    }
  }
  // Clean dead monsters
  monsters=monsters.filter(m=>m.state!=='dead');
  // Update player
  updatePlayer(dt);
  // Update damage numbers
  for(const d of dmgNums)d.age+=dt;
  dmgNums=dmgNums.filter(d=>d.age<S.visuals.dmg_num_lifetime);
  // Particles
  for(const p of particles){
    p.age+=dt;
    p.x+=p.vx;
    p.y+=p.vy;
    p.vy+=p.gravity*dt;
  }
  particles=particles.filter(p=>p.age<p.maxAge);
  // Items (auto-collect after delay)
  for(const it of items)it.age+=dt;
  items=items.filter(it=>it.age<S.items.despawn_time);
  // UI
  document.getElementById('lvlText').textContent=`Base Lv. ${player.baseLv} / Job Lv. ${player.jobLv}`;
  document.getElementById('hpBar').style.width='100%';
  document.getElementById('spBar').style.width='80%';
  document.getElementById('expBar').style.width=`${(player.exp/player.expMax)*100}%`;
  document.getElementById('killText').textContent=`Kills: ${kills} | Zeny: ${zeny}`;
}

function updatePlayer(dt){
  const p=player;
  // Find target
  if(!p.target||p.target.state==='dead'||p.target.state==='dying'){
    p.target=null;
    let minD=Infinity;
    for(const m of monsters){
      if(m.state==='dead'||m.state==='dying')continue;
      const d=Math.hypot(m.x-p.x,m.y-p.y);
      if(d<minD){minD=d;p.target=m}
    }
  }
  // Click move
  if(clickTarget){
    const dx=clickTarget.x-p.x,dy=clickTarget.y-p.y;
    const dist=Math.hypot(dx,dy);
    if(dist>5){
      p.x+=dx/dist*p.moveSpeed;
      p.y+=dy/dist*p.moveSpeed;
      p.state='walking';
      p.direction=moveDir(dx,dy);
      p.frameTimer+=dt;
      if(p.frameTimer>0.1){p.frameTimer=0;p.frame=(p.frame+1)%8}
      return;
    }else{clickTarget=null}
  }
  // Auto-hunt
  if(p.target){
    const m=p.target;
    const dx=m.x-p.x,dy=m.y-p.y;
    const dist=Math.hypot(dx,dy);
    p.direction=moveDir(dx,dy);
    if(dist>S.player.attack_range){
      // Walk toward
      p.x+=dx/dist*p.moveSpeed;
      p.y+=dy/dist*p.moveSpeed;
      p.state='walking';
      p.frameTimer+=dt;
      if(p.frameTimer>0.1){p.frameTimer=0;p.frame=(p.frame+1)%8}
    }else{
      // In range, attack
      p.atkTimer-=dt*1000;
      if(p.atkTimer<=0){
        p.state='attacking';
        p.frame=0;p.frameTimer=0;
        doAttack(m);
        // Double attack chance
        if(Math.random()<S.combat.double_attack_chance){
          setTimeout(()=>{
            if(m.state!=='dead'&&m.state!=='dying')doAttack(m);
          },S.combat.double_attack_delay_ms);
        }
        p.atkTimer=p.atkCooldown;
      }else if(p.state==='attacking'){
        p.frameTimer+=dt;
        // Animation plays over ~700ms (or less at high ASPD), then returns to idle
        const animDur=Math.min(0.7,p.atkCooldown/1000);
        const frameDur=animDur/5;
        if(p.frameTimer>frameDur){
          p.frameTimer=0;
          if(p.frame<4)p.frame++;
          else{p.state='idle';p.frame=0}
        }
      }else{
        p.state='idle';p.frame=0;
      }
    }
  }else{
    p.state='idle';p.frame=0;
  }
}

function doAttack(m){
  if(!m||m.state==='dead'||m.state==='dying')return;
  const isCrit=Math.random()<S.combat.crit_chance;
  const base=S.combat.damage_base+player.str+player.baseLv*S.combat.damage_per_level;
  let dmg=base+Math.floor(Math.random()*S.combat.damage_variance);
  if(isCrit)dmg=Math.floor(dmg*S.combat.crit_multiplier);
  // Cleave (hit nearby monsters too)
  const nearby=monsters.filter(om=>om!==m&&om.state!=='dead'&&om.state!=='dying'&&Math.hypot(om.x-m.x,om.y-m.y)<S.combat.cleave_range);
  if(nearby.length>0&&Math.random()<S.combat.cleave_chance){
    const t=nearby[0];
    const cd=Math.floor(dmg*S.combat.cleave_damage_ratio);
    t.hp-=cd;t.hurtTimer=S.monsters.hurt_duration;
    addDmgNum(t.x,t.y,cd,false,false);
    sndHit();
    if(t.hp<=0)killMonster(t);
  }
  m.hp-=dmg;
  m.hurtTimer=S.monsters.hurt_duration;
  addDmgNum(m.x,m.y,dmg,isCrit,false);
  if(isCrit){
    sndCrit();
    shakeTimer=S.visuals.crit_shake_duration;
    addParticles(m.x,m.y,'#ff0',S.particles.crit_count);
  }else{sndHit()}
  if(m.hp<=0)killMonster(m);
}

function killMonster(m){
  m.state='dying';m.dieTimer=0;
  kills++;
  killsSinceLastBoss++;
  // Boss spawn check: every N kills, if no boss alive
  if(killsSinceLastBoss>=S.boss.kill_interval&&!monsters.some(mm=>mm.isBoss&&mm.state!=='dead'&&mm.state!=='dying')){
    killsSinceLastBoss=0;
    spawnBossGroup();
  }
  sndDie();
  const color=MONSTER_TYPES[m.type]?MONSTER_TYPES[m.type].deathColor:'#ffffff';
  if(m.isBoss){
    addParticles(m.x,m.y,'#ffd700',S.particles.boss_death_gold);
    addParticles(m.x,m.y,color,S.particles.boss_death_type);
    addParticles(m.x,m.y,'#fff',S.particles.boss_death_white);
    shakeTimer=S.boss.death_shake_duration;
  }else{
    addParticles(m.x,m.y,color,S.particles.normal_death_type);
    addParticles(m.x,m.y,'#fff',S.particles.normal_death_white);
  }
  // EXP
  player.exp+=m.expReward;
  player.jobExp+=Math.floor(m.expReward*S.progression.job_exp_ratio);
  zeny+=m.zenyReward+Math.floor(Math.random()*S.progression.zeny_bonus_max);
  // Level up
  if(player.exp>=player.expMax){
    player.exp-=player.expMax;
    player.baseLv++;
    player.expMax=Math.floor(player.expMax*S.progression.exp_multiplier_per_level);
    player.str+=S.progression.str_per_level;
    player.atkCooldown=Math.max(S.progression.min_atk_cooldown,player.atkCooldown-S.progression.atk_cooldown_reduction_per_level);
    lvlupEl.textContent='Base Level Up! Lv.'+player.baseLv;
    lvlupEl.style.opacity='1';lvlupTimer=S.visuals.levelup_display_duration;
    sndLvl();
    addParticles(player.x,player.y,'#ff0',S.particles.levelup_gold);
    addParticles(player.x,player.y,'#fff',S.particles.levelup_white);
  }
  if(player.jobExp>=player.jobExpMax){
    player.jobExp-=player.jobExpMax;
    player.jobLv++;
    player.jobExpMax=Math.floor(player.jobExpMax*S.progression.job_exp_multiplier_per_level);
  }
  // Item drops
  if(Math.random()<S.items.drop_chance){
    const types=S.items.drop_types;
    addItem(m.x,m.y,types[Math.floor(Math.random()*types.length)]);
  }
}

// Cached tint canvas
const _tintCanvas=document.createElement('canvas');
const _tintCtx=_tintCanvas.getContext('2d');

// Drawing
function drawSprite(img,frame,x,y,scale,flipX,alpha,tint){
  if(!img||!frame)return;
  const [sx,sy,sw,sh]=frame;
  const dw=sw*scale,dh=sh*scale;
  const dx=x-dw/2,dy=y-dh;
  ctx.save();
  if(alpha!==undefined)ctx.globalAlpha=alpha;
  if(tint){
    if(_tintCanvas.width<sw)_tintCanvas.width=sw;
    if(_tintCanvas.height<sh)_tintCanvas.height=sh;
    _tintCtx.clearRect(0,0,sw,sh);
    _tintCtx.globalCompositeOperation='source-over';
    _tintCtx.drawImage(img,sx,sy,sw,sh,0,0,sw,sh);
    _tintCtx.globalCompositeOperation='source-atop';
    _tintCtx.fillStyle=tint;
    _tintCtx.fillRect(0,0,sw,sh);
    if(flipX){
      ctx.translate(dx+dw,dy);ctx.scale(-1,1);
      ctx.drawImage(_tintCanvas,0,0,sw,sh,0,0,dw,dh);
    }else{
      ctx.drawImage(_tintCanvas,0,0,sw,sh,dx,dy,dw,dh);
    }
  }else{
    if(flipX){
      ctx.translate(dx+dw,dy);ctx.scale(-1,1);
      ctx.drawImage(img,sx,sy,sw,sh,0,0,dw,dh);
    }else{
      ctx.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh);
    }
  }
  ctx.restore();
}

function drawShadow(x,y,rx,ry){
  ctx.save();
  ctx.globalAlpha=0.3;
  ctx.fillStyle='#000';
  ctx.beginPath();
  ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawDmgNum(d){
  const progress=d.age/S.visuals.dmg_num_lifetime;
  const alpha=progress<0.7?1:1-(progress-0.7)/0.3;
  const yOff=-d.age*S.visuals.dmg_num_rise_speed;
  const x=d.x+d.offsetX;
  const y=d.startY+yOff;
  // Scale pop effect
  let s=d.scale;
  if(d.age<0.08)s*=1+d.age/0.08*0.3;
  else if(d.age<0.15)s*=1.3-(d.age-0.08)/0.07*0.3;
  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.translate(x,y);
  ctx.scale(s,s);
  const text=d.isMiss?'Miss':String(d.val);
  const fontSize=d.isCrit?S.visuals.dmg_num_crit_font_size:S.visuals.dmg_num_normal_font_size;
  ctx.font=`900 ${fontSize}px Impact,Arial Black,sans-serif`;
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  // Dark outline (thick)
  ctx.strokeStyle='rgba(0,0,0,0.9)';
  ctx.lineWidth=S.visuals.dmg_num_stroke_width;
  ctx.lineJoin='round';
  ctx.strokeText(text,0,0);
  // Gradient fill
  const grad=ctx.createLinearGradient(0,-fontSize/2,0,fontSize/2);
  if(d.isCrit){
    grad.addColorStop(0,'#ffff80');
    grad.addColorStop(0.5,'#ffdd00');
    grad.addColorStop(1,'#ff8800');
  }else if(d.isMiss){
    grad.addColorStop(0,'#ccc');
    grad.addColorStop(1,'#888');
  }else{
    grad.addColorStop(0,'#ffffff');
    grad.addColorStop(0.5,'#eeeeee');
    grad.addColorStop(1,'#cccccc');
  }
  ctx.fillStyle=grad;
  ctx.fillText(text,0,0);
  // Inner highlight
  ctx.globalAlpha=alpha*0.4;
  ctx.fillStyle='#fff';
  ctx.fillText(text,0,-1);
  ctx.restore();
}

function drawMonsterLabel(m){
  if(m.state==='dying'||m.state==='dead')return;
  const typeDef=MONSTER_TYPES[m.type];
  const bossScale=m.isBoss?S.boss.scale_multiplier:1;
  const name=m.isBoss?(m.bossName||'Boss'):(typeDef?typeDef.name:m.type);
  const spriteH=typeDef?typeDef.idle[0][3]*typeDef.scale*bossScale:40*SCALE;
  const y=m.y-spriteH-8;
  ctx.save();
  ctx.font=m.isBoss?'bold 13px Tahoma,Arial':'bold 11px Tahoma,Arial';
  ctx.textAlign='center';
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.fillText(name,m.x+1,y+1);
  ctx.fillStyle=m.isBoss?'#ffd700':'#fff';
  ctx.fillText(name,m.x,y);
  // HP bar
  if(m.hp<m.maxHp&&m.hp>0){
    const bw=m.isBoss?S.boss.hp_bar_width:Math.min(60,30+m.maxHp/10),bh=m.isBoss?S.boss.hp_bar_height:4;
    ctx.fillStyle='rgba(0,0,0,0.5)';
    ctx.fillRect(m.x-bw/2,y+3,bw,bh);
    ctx.fillStyle=m.isBoss?'#d4a017':'#e33';
    ctx.fillRect(m.x-bw/2,y+3,bw*(m.hp/m.maxHp),bh);
    ctx.strokeStyle='rgba(0,0,0,0.7)';
    ctx.lineWidth=0.5;
    ctx.strokeRect(m.x-bw/2,y+3,bw,bh);
  }
  ctx.restore();
}

function drawItem(it){
  const fadeStart=S.items.despawn_time-0.5;
  const alpha=it.age>fadeStart?1-(it.age-fadeStart)/0.5:1;
  const bob=Math.sin(it.age*S.items.bob_speed)*S.items.bob_amplitude;
  ctx.save();
  ctx.globalAlpha=alpha;
  ctx.translate(it.x,it.y+bob);
  const colors={jellyfish:'#8f8',apple:'#f44',knife:'#ccc',candy:'#f8f'};
  ctx.fillStyle=colors[it.type]||'#ff0';
  ctx.beginPath();
  ctx.arc(0,-4,5,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,0.5)';
  ctx.lineWidth=1;
  ctx.stroke();
  ctx.restore();
}

function render(){
  ctx.save();
  ctx.translate(shakeX,shakeY);
  // Terrain
  if(terrainCanvas)ctx.drawImage(terrainCanvas,0,0);
  // Collect entities for Y-sort
  const entities=[];
  // Monsters
  for(const m of monsters){
    if(m.state==='dead')continue;
    entities.push({type:'monster',obj:m,y:m.y});
  }
  // Player
  entities.push({type:'player',obj:player,y:player.y});
  // Items
  for(const it of items){
    entities.push({type:'item',obj:it,y:it.y});
  }
  entities.sort((a,b)=>a.y-b.y);
  // Draw entities
  for(const e of entities){
    if(e.type==='monster')drawMonster(e.obj);
    else if(e.type==='player')drawPlayer(e.obj);
    else if(e.type==='item')drawItem(e.obj);
  }
  // Particles
  for(const p of particles){
    const alpha=1-p.age/p.maxAge;
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.size*(1-p.age/p.maxAge),0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  // Damage numbers (on top of everything)
  for(const d of dmgNums)drawDmgNum(d);
  ctx.restore();
}

function drawMonster(m){
  const typeDef=MONSTER_TYPES[m.type];
  if(!typeDef)return;
  const frames=typeDef.idle;
  const hurtFrames=typeDef.hurt;
  const img=sprites[typeDef.sprite];
  if(!img)return;
  let frame=frames[m.frame%frames.length];
  let alpha=1;
  let tint=null;
  if(m.state==='dying'){
    alpha=1-m.dieTimer/S.monsters.death_duration;
    tint='rgba(255,255,255,0.5)';
  }
  if(m.hurtTimer>0){
    tint='rgba(255,100,100,0.4)';
    if(hurtFrames.length>0)frame=hurtFrames[0];
  }
  const bossScale=m.isBoss?S.boss.scale_multiplier:1;
  // Target indicator
  if(player.target===m&&m.state!=='dying'){
    const [sx,sy]=typeDef.shadow;
    ctx.save();
    ctx.strokeStyle=m.isBoss?'rgba(255,215,0,0.7)':'rgba(255,255,255,0.6)';
    ctx.lineWidth=m.isBoss?2:1.5;
    ctx.setLineDash([4,3]);
    ctx.beginPath();
    ctx.ellipse(m.x,m.y+2,(sx+6)*bossScale,(sy+3)*bossScale,0,0,Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }
  // Boss aura
  if(m.isBoss&&m.state!=='dying'){
    ctx.save();
    const pulse=0.7+0.3*Math.sin(gameTime*S.boss.aura_pulse_speed);
    ctx.globalAlpha=0.35*pulse;
    const aura=S.boss.aura_size;
    const grad=ctx.createRadialGradient(m.x,m.y,5,m.x,m.y,aura*bossScale);
    grad.addColorStop(0,'rgba(255,215,0,0.6)');
    grad.addColorStop(0.5,'rgba(255,180,0,0.3)');
    grad.addColorStop(1,'rgba(255,100,0,0)');
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.ellipse(m.x,m.y,aura*bossScale,20*bossScale,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  // Shadow
  drawShadow(m.x,m.y,typeDef.shadow[0]*bossScale,typeDef.shadow[1]*bossScale);
  // Sprite
  const sc=typeDef.scale*bossScale*(m.state==='dying'?1-m.dieTimer*0.5:1);
  drawSprite(img,frame,m.x,m.y,sc,false,alpha,tint);
  // Name label
  drawMonsterLabel(m);
}

function drawPlayer(p){
  const bodyImg=sprites.sword;
  const headImg=sprites.head;
  const wpnImg=sprites.weapon;
  if(!bodyImg)return;
  const [fd,flipX]=dirInfo(p.direction);
  let bodyFrame,headFrame,anchorKey;
  if(p.state==='attacking'){
    const atkFrames=SWORD_ATK_DIR[fd];
    bodyFrame=atkFrames[Math.min(p.frame,atkFrames.length-1)];
    headFrame=HEAD_DIR[fd];
    anchorKey='attack';
  }else if(p.state==='walking'){
    const walkFrames=SWORD_WALK_DIR[fd];
    bodyFrame=walkFrames[p.frame%walkFrames.length];
    headFrame=HEAD_DIR[fd];
    anchorKey='walk';
  }else{
    bodyFrame=SWORD_STAND_DIR[fd];
    headFrame=HEAD_DIR[fd];
    anchorKey='stand';
  }
  // Shadow
  drawShadow(p.x,p.y,20,9);
  // Draw body
  drawSprite(bodyImg,bodyFrame,p.x,p.y,SCALE,flipX);
  // Draw head on top of body
  if(headImg){
    // Use standing frame height as stable reference during walking
    const refH=(p.state==='walking'?SWORD_STAND_DIR[fd][3]:bodyFrame[3])*SCALE;
    let overlap;
    if(p.state==='attacking'){
      // Per-frame head anchor tracks body crouch during attack swing
      overlap=HEAD_ANCHOR_ATK[Math.min(p.frame,4)]*SCALE;
    }else{
      overlap=HEAD_ANCHOR[p.state==='walking'?'stand':anchorKey]*SCALE;
    }
    const headY=p.y-refH+overlap;
    drawSprite(headImg,headFrame,p.x,headY,SCALE,flipX);
  }
  // Draw weapon during attack
  if(p.state==='attacking'&&wpnImg){
    const fi=Math.min(p.frame,4);
    // Direct 1:1 frame mapping (5 weapon frames for 5 body frames)
    const wpnFrame=WPN_ATK_DIR[fd][fi];
    const wpnScale=SCALE*0.9;
    // Calculate hand position from body frame using per-frame fractions
    const bodyW=bodyFrame[2]*SCALE;
    const bodyH=bodyFrame[3]*SCALE;
    const hp=WPN_HAND_POS[fd][fi];
    // Hand position in screen coords (flip x fraction when mirrored)
    const hpx=flipX?(1-hp[0]):hp[0];
    const handX=p.x-bodyW/2+bodyW*hpx;
    const handY=p.y-bodyH+bodyH*hp[1];
    // Draw weapon with grip point at hand position
    // Grip offset shifts weapon up so grip (below center) aligns with hand
    const [sx,sy,sw,sh]=wpnFrame;
    const dw=sw*wpnScale,dh=sh*wpnScale;
    const gripOff=dh*WPN_GRIP_OFF[fi];
    ctx.save();
    if(flipX){
      ctx.translate(handX+dw/2,handY-dh/2-gripOff);
      ctx.scale(-1,1);
      ctx.drawImage(wpnImg,sx,sy,sw,sh,0,0,dw,dh);
    }else{
      ctx.drawImage(wpnImg,sx,sy,sw,sh,handX-dw/2,handY-dh/2-gripOff,dw,dh);
    }
    ctx.restore();
  }
  // Name label (above the head)
  const totalH=bodyFrame[3]*SCALE+(headFrame?headFrame[3]*SCALE*0.5:0);
  const ny=p.y-totalH-4;
  ctx.save();
  ctx.font='bold 11px Tahoma,Arial';
  ctx.textAlign='center';
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.fillText('Swordsman',p.x+1,ny+1);
  ctx.fillStyle='#8ff';
  ctx.fillText('Swordsman',p.x,ny);
  ctx.restore();
}

// Game loop
function gameLoop(time){
  const dt=Math.min((time-lastTime)/1000,0.05);
  lastTime=time;
  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

// Input
canvas.addEventListener('click',e=>{
  if(audioCtx.state==='suspended')audioCtx.resume();
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*(W/rect.width);
  const y=(e.clientY-rect.top)*(H/rect.height);
  // Check if clicked on a monster
  let clickedMonster=null;
  for(const m of monsters){
    if(m.state==='dead'||m.state==='dying')continue;
    if(Math.hypot(m.x-x,m.y-y)<30){clickedMonster=m;break}
  }
  if(clickedMonster){
    player.target=clickedMonster;
    clickTarget=null;
  }else{
    clickTarget={x,y};
  }
});

// Cursor change on monster hover
canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*(W/rect.width);
  const y=(e.clientY-rect.top)*(H/rect.height);
  let onMonster=false;
  for(const m of monsters){
    if(m.state==='dead'||m.state==='dying')continue;
    if(Math.hypot(m.x-x,m.y-y)<30){onMonster=true;break}
  }
  canvas.style.cursor=onMonster?'pointer':'default';
});

// Start
function startGame(){
  document.getElementById('loading').style.display='none';
  genTerrain();
  initPlayer();
  processMonsterStats();
  buildAllMonsters();
  // Initial monsters
  for(let i=0;i<S.spawning.initial_monster_count;i++)spawnMonster();
  lastTime=performance.now();
  requestAnimationFrame(gameLoop);
}
</script>
</body>
</html>
